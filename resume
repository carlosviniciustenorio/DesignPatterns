Criacional
    Singleton: assegura que somente um objeto de uma determinada classe seja criado em todo o projeto;
    Abstract Factory: permite que um cliente crie famílias de objetos sem especificar suas classes concretas;
    Builder: encapsular a construção de um produto e permitir que ele seja construído em etapas;
    Prototype: permite você criar novas instancias simplesmente copiando instancias existentes;
    Factory Mathod: as subclasses decidem quais classes concretas serão criadas.

Estruturais
    Decorator: envelopa um objeto para fornecer novos comportamentos;
    Proxy: envelopa um objeto para controlar o acesso a ele;
    FlyWeigth: uma instancia de uma classe pode ser usada para fornecer muitas “instancias virtuais”;
    Facade: simplifica a "interface" de um conjunto de classes;
    Composite: Os clientes tratam as coleções de objetos e os objetos individuais de maneira uniforme;
    Bridge: permite criar uma ponte para variar não apenas a sua implementação, como também as suas abstrações;
    Adapter: envelopa um objeto e fornece a ele uma interface diferente;

Comportamental
    Template Method: As subclasses decidem como implementar os passos de um algoritimo;
    Visitor: permite acrescentar novos recursos a um composto de objetos e o encapsulamento não é importante;
    Command: encapsula uma solicitação como um objeto;
    Strategy: encapsula comportamentos intercambiáveis e usa a delegação para decidir qual deles será usado;
    Chair of Responsability: permite dar a mais de um objeto a oportunidade de processar uma solicitação;
    Iterator: fornece uma maneira de acessar seqüencialmente uma coleção de objetos sem expor a sua implementação;
    Mediator: centraliza operações complexas de comunicação e controle entre objetos relacionados;
    Memento: permite restaurar um objeto a um dos seus estados prévios, por exemplo, quando o usuário seleciona um “desfazer”;
    Interpreter: permite construir um intérprete para uma linguagem;
    State: encapsula comportamentos baseados em estados e usa a delegação para alternar comportamentos;
    Observer: permite notificar outros objetos quando ocorre uma mudança de estado.