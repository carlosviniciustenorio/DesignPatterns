Criacional
    Singleton: assegura que somente um objeto de uma determinada classe seja criado em todo o projeto;
    Abstract Factory: permite que um cliente crie famílias de objetos sem especificar suas classes concretas;
    Builder: encapsular a construção de um produto e permitir que ele seja construído em etapas;
    Prototype: permite você criar novas instancias simplesmente copiando instancias existentes;
    Factory Mathod: as subclasses decidem quais classes concretas serão criadas.

Estruturais
    Decorator: envelopa um objeto para fornecer novos comportamentos;
    Proxy: envelopa um objeto para controlar o acesso a ele. Sendo assim, duas aplicações não se comunicam diretamente e sim se comunicam com o proxy;
            Ex: Rede de internet que não permite você se conectar com o Facebook

            Smart: Adicionar funcionalidades extras que nem a aplicaçã real nem a aplicação cliente possuem.
                Ex: Logs

            Protection: Restringir ações do cliente. O Azure fornece isso nos bancos de dados e é um exemplo de Proxy
            
            Cache: Camada que define o que vai ser consultado de fato no banco de dados por questão de performance

            Virtual: Simplificação do acesso a um recurso externo
                        Ex: Criar uma biblioteca para facilitar o consumo de uma biblioteca externa complexa
                        
            Remote: Middleware para acessar recursos remotos.
                        Ex: Acesso a um banco de dados utilizando bibliotecas, SQL Server no Startup.

    FlyWeigth: uma instancia de uma classe pode ser usada para fornecer muitas “instancias virtuais”;
    Facade: simplifica a "interface" de um conjunto de classes;
    Composite: Os clientes tratam as coleções de objetos e os objetos individuais de maneira uniforme;
    Bridge: permite criar uma ponte para variar não apenas a sua implementação, como também as suas abstrações;
    Adapter: envelopa um objeto e fornece a ele uma interface diferente;

Comportamental
    Template Method: As subclasses decidem como implementar os passos de um algoritimo;
    Visitor: permite acrescentar novos recursos a um composto de objetos e o encapsulamento não é importante;
    Command: encapsula uma solicitação como um objeto;
    Strategy: encapsula comportamentos intercambiáveis e usa a delegação para decidir qual deles será usado;
    Chair of Responsability: permite dar a mais de um objeto a oportunidade de processar uma solicitação;
    Iterator: fornece uma maneira de acessar seqüencialmente uma coleção de objetos sem expor a sua implementação;
    Mediator: centraliza operações complexas de comunicação e controle entre objetos relacionados;
    Memento: permite restaurar um objeto a um dos seus estados prévios, por exemplo, quando o usuário seleciona um “desfazer”;
    Interpreter: permite construir um intérprete para uma linguagem;
    State: encapsula comportamentos baseados em estados e usa a delegação para alternar comportamentos;
    Observer: permite notificar outros objetos quando ocorre uma mudança de estado.